---
name: loop-test-build


env:
# settings DEFAULTS
#  clear-docker-cache: ${{ github.event.inputs.clear-docker-cache }}
  clear-docker-cache: ${{ inputs.backport_release == false && inputs.release_candidate == false }}
#  clear-docker-cache: ${{ github.event.inputs.clear-docker-cache && github.event.inputs.clear-docker-cache != 'false' }}
#  clear-docker-cache: 'false'
#  build-with-CCACHE: ${{ github.event.inputs.build-with-CCACHE }}
  build-with-CCACHE: ${{ github.event.inputs.build-with-CCACHE && github.event.inputs.build-with-CCACHE != 'false' }}
#  build-with-CCACHE: 'false'
#  build-with-SCCACHE: ${{ github.event.inputs.build-with-SCCACHE }}
#  build-with-SCCACHE: ${{ github.event.inputs.build-with-SCCACHE && github.event.inputs.build-with-SCCACHE != 'false' }}
  build-with-SCCACHE: 'true'
  build-Everything: ${{ github.event.inputs.build-Everything && github.event.inputs.build-Everything != 'false' }}
  ryanchapman-gha-ssh: ${{ github.event.inputs.ryanchapman-gha-ssh && github.event.inputs.ryanchapman-gha-ssh != 'false' }}


on:
  push:
  #  branches: [ master ]
    #paths-ignore:
    #  - '.github/workflows/**'
    paths:
      - '!.github/workflows/**'
      - '.github/workflows/loop-test-build.yml'
  workflow_dispatch:
    inputs:
      clear-docker-cache:
        description: 'clear docker cache with rm -fr /tmp/.buildx-cache /tmp/.buildx-cache-old /tmp/.buildx-cache-new'     
        required: false 
        type: boolean
      build-with-CCACHE:
        description: 'build with build-with-CCACHE'     
        required: false 
        type: boolean
        default: false
      build-with-SCCACHE:
        description: 'SCCACHE build'     
        required: false 
        type: boolean
        default: true
      build-Everything:
        description: 'build-Everything'     
        required: false 
        type: boolean
        default: false
      ryanchapman-gha-ssh:
        description: 'ryanchapman-gha-ssh'     
        required: false 
        type: boolean
        default: false
  pull_request:

# https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-secrets
# https://docs.github.com/en/actions/security-guides/automatic-token-authentication
permissions:
  packages: read
  contents: read

jobs:
  x86:
    name: x86-loop-test
    runs-on: ubuntu-20.04
    steps:
      # FIXME BUG see https://github.com/actions/runner/issues/1483
      - if: ${{ github.event.inputs.clear-docker-cache && github.event.inputs.clear-docker-cache != 'false' }}
        run: echo "clear-docker-cache=true" >> $GITHUB_OUTPUT
      - if: ${{ github.event.inputs.build-with-CCACHE && github.event.inputs.build-with-CCACHE != 'false' }}
        run: echo "build-with-CCACHE=true" >> $GITHUB_OUTPUT
      - if: ${{ github.event.inputs.build-with-SCCACHE && github.event.inputs.build-with-SCCACHE != 'false' }}
        run: echo "build-with-SCCACHE=true" >> $GITHUB_OUTPUT
      - if: ${{ github.event.inputs.build-Everything && github.event.inputs.build-Everything != 'false' }}
        run: echo "build-Everything=true" >> $GITHUB_OUTPUT
#    
#    - if: ${{ github.event.inputs.OPT_REBUILD && github.event.inputs.OPT_REBUILD != 'false' }}
#      run: echo "OPT_REBUILD=1" >> $GITHUB_OUTPUT
#    - if: ${{ github.event.inputs.OPT_PACKAGE_ONLY && github.event.inputs.OPT_PACKAGE_ONLY != 'false' }}
#      run: echo "OPT_PACKAGE_ONLY=1" >> $GITHUB_OUTPUT
#    - if: ${{ github.event.inputs.OPT_PUSH_WHEN_FAIL && github.event.inputs.OPT_PUSH_WHEN_FAIL != 'false' }}
#      run: echo "OPT_PUSH_WHEN_FAIL=1" >> $GITHUB_OUTPUT
#    - if: ${{ github.event.inputs.OPT_IGNORE_ERRORS && github.event.inputs.OPT_IGNORE_ERRORS != 'false' }}
#      run: echo "OPT_IGNORE_ERRORS=1" >> $GITHUB_OUTPUT
#    - if: ${{ github.event.inputs.OPT_DEBUG && github.event.inputs.OPT_DEBUG != 'false' }}
#      run: echo "OPT_DEBUG=1" >> $GITHUB_OUTPUT

      - name: Check out code
        uses: actions/checkout@v3
        with:
          repository: ipxe/ipxe
          path: .
          fetch-depth: 0
      - name: Install packages
        run: |
          sudo dpkg --add-architecture i386
          sudo apt update
          sudo apt install \
          -y -o Acquire::Retries=50 \
          mtools syslinux isolinux \
          libc6-dev-i386 libc6-dbg:i386 valgrind \
          p7zip-full genisoimage mtools isolinux syslinux syslinux-efi syslinux-utils xorriso

      - name: "build-with-SCCACHE != 'true'"
        if: ${{ env.BUILD-WITH-SCCACHE != 'true' }}
        run: |
          echo build-with-SCCACHE
          
        # https://github.com/Mozilla-Actions/sccache-action
      - name: Run sccache-cache
        if: ${{ env.build-with-SCCACHE == 'true' }} 
        uses: mozilla-actions/sccache-action@v0.0.3
        with:
          version: "v0.4.0"
      - name: Run sccache stat for check
        if: ${{ env.build-with-SCCACHE == 'true' }}
        shell: bash
        run: ${SCCACHE_PATH} --show-stats

      - name: For C/C++ code, the following environment variables should be set
        if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_OUTPUT
          echo "CC=sccache gcc" >> $GITHUB_OUTPUT
          echo "CXX=sccache gcc" >> $GITHUB_OUTPUT
      - name: export -p | grep CCACHE SCCACHE CC CXX
        ### if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          export -p | grep -E "CCACHE|SCCACHE|CC|CXX|PATH"
      - name: export -p | grep CCACHE SCCACHE CC CXX
        ### if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          export -p | grep -E "CCACHE|SCCACHE|CC|CXX|PATH"
          sccache --show-stats ||:
          ccache --show-stats --verbose ||:
#        env:
#          SCCACHE_GHA_ENABLED: "true"
#          CC: "sccache gcc"
#          CXX: "sccache gcc"
        # With cmake, add the following argument:
        # -DCMAKE_C_COMPILER_LAUNCHER=sccache
        # -DCMAKE_CXX_COMPILER_LAUNCHER=sccache
        # With gcc / configure, call it with:
        # ./configure CC="sccache gcc" CXX="sccache gcc"
        #  With clang
        #  ./configure CC="sccache clang" CXX="sccache clang"
      - name: build test.c
        run: |
          cat <<EOF > test.c
          #include <stdio.h>
          void foo() {
          printf("hello world\n");
          }
          EOF
          
      - name: Add sccache warper1
        if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          # By default, sccache will fail your build if it fails to successfully communicate with its associated server. To have sccache instead gracefully failover to the local compiler without stopping, set the environment variable SCCACHE_IGNORE_SERVER_IO_ERROR=1.
          echo build-with-SCCACHE
          # see https://github.com/mozilla/sccache/issues/1155#issuecomment-1097557677
          sudo mkdir -p /usr/lib/sccache/
          cat <<EOS | sudo tee /usr/lib/sccache/sccache-wrapper
          #!/usr/bin/bash
          SCCACHE_BIN "$(command -v sccache )"
          $(dirname "$0")
          for COMPILER in "c++" "c89" "c99" "cc" "clang" "clang++" "cpp" "g++" "gcc" "rustc" "x86_64-pc-linux-gnu-c++" "x86_64-pc-linux-gnu-cc" "x86_64-pc-linux-gnu-g++" "x86_64-pc-linux-gnu-gcc" "arm-none-eabi-c++" "arm-none-eabi-cc" "arm-none-eabi-g++" "arm-none-eabi-gcc" "aarch64-linux-gnu-c++" "aarch64-linux-gnu-cc" "aarch64-linux-gnu-g++" "aarch64-linux-gnu-gcc" "arm-none-eabi-c++" "arm-none-eabi-cc" "arm-none-eabi-g++" "arm-none-eabi-gcc"; do
            cat > "./${COMPILER}" <<-EOF
            #!/bin/bash
            SCCACHE_WRAPPER_BINDIR="\$(dirname \${BASH_SOURCE[0]})"  # Intentionally don't resolve symlinks
            PATH=\${PATH//":\$SCCACHE_WRAPPER_BINDIR:"/":"} # delete any instances in the middle
            PATH=\${PATH/#"\$SCCACHE_WRAPPER_BINDIR:"/} # delete any instance at the beginning
            PATH=\${PATH/%":\$SCCACHE_WRAPPER_BINDIR"/} # delete any instance in the at the end
            # /usr/bin/sccache ${COMPILER} "\$@"
            ${SCCACHE_BIN} ${COMPILER} "\$@"
              EOF
              chmod 755 "./${COMPILER}"
            done
          EOS
          sudo chmod 755 /usr/lib/sccache/sccache-wrapper
          sudo /usr/lib/sccache/sccache-wrapper
          ls -latr /usr/lib/sccache/ ||:
###          echo "/usr/lib/sccache" >> $GITHUB_PATH
          
      - name: Add sccache warper2
        if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          # By default, sccache will fail your build if it fails to successfully communicate with its associated server. To have sccache instead gracefully failover to the local compiler without stopping, set the environment variable SCCACHE_IGNORE_SERVER_IO_ERROR=1.
          echo build-with-SCCACHE
          cat <<EOF > /usr/local/bin/CC
          #!/bin/sh
          #exec ccache "${TARGET_CC_NOCACHE}" "$@"
          exec SCCACHE_GHA_ENABLED=true SCCACHE_ERROR_LOG=/tmp/sccache_log.txt SCCACHE_LOG=debug sccache gcc "$@"
          EOF
          chmod 755 /usr/local/bin/CC
          cat <<EOF > /usr/local/bin/CXX
          #!/bin/sh
          #exec ccache "${TARGET_CXX_NOCACHE}" "$@"
          exec SCCACHE_GHA_ENABLED=true SCCACHE_ERROR_LOG=/tmp/sccache_log.txt SCCACHE_LOG=debug sccache g++ "$@"
          EOF
          chmod 755 /usr/local/bin/CXX
          sccache --start-server ||:


      - name: install ccache
        if: ${{ env.build-with-CCACHE == 'true' }}
        uses: berlin4apk/ccache-action@dev
        with:
          key: ${{ matrix.os }}-${{ matrix.type }}
          verbose: 2 # "Verbosity level: 0 (default), 1 or 2. Ignore for sccache."
          max-size: 1000M # Max size of the cache, default: 500M
          compression-level: 0 # ccache compression-level, ccache 3.7.7 uses gzip: a Normal value is 6 (0-9),  ccache 3.7.7 uses zstd:  a Normal value is 0 (-5-19) see https://ccache.dev/manual/4.6.html#config_compression_level
          install-from-github: true
          variant: ccache # 'Ccache variant to use. Either "ccache" (the default) or "sccache" (see https://github.com/mozilla/sccache)'
          # save: false # If 'false', do not save the cache, only restore. default: true
          # ccache-dir: "~/.ccache"
          # dont-do-config: false


      - name: echo PATH
        run: |
          echo "$PATH"
      - name: Add ccache /usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec to GITHUB_PATH
        if: ${{ env.build-with-CCACHE == 'true' }}
        run: |
          echo "/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec" >> $GITHUB_PATH
      - name: Add ccache /usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec to GITHUB_PATH
        if: ${{ env.build-with-SCCACHE == 'true' }}
        run: |
          echo "/usr/local/lib/sccache:/usr/lib/sccache:/usr/local/opt/sccache/libexec" >> $GITHUB_PATH
      - name: echo PATH
        run: |
          echo "$PATH"



# https://github.com/ipxe/ipxe/discussions/614#discussioncomment-2363937          
# @mcb30 on Mar 15, 2022
# The default build will give you a BIOS image. To build an EFI image, you will need to do something like make bin-x86_64-efi/ipxe.iso.
#
# For the record: the prebuilt ISO published at https://boot.ipxe.org/ipxe.iso is a combination of the BIOS, x86_64 EFI, and Aarch64 EFI images, built using the equivalent of:
# make bin/ipxe.lkrn bin-x86_64-efi/ipxe.efi
# make bin-arm64-efi/ipxe.efi CROSS=aarch64-linux-gnu-
# ./util/genfsimg -o ipxe.iso bin/ipxe.lkrn bin-x86_64-efi/ipxe.efi bin-arm64-efi/ipxe.efi
#
# The Makefile does not currently support building this combined ISO in one step as a single target, since it involves compiling for multiple CPU architectures.
          
      - name: Build (BIOS)
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          make -j $((`nproc`+0)) -C src
      - name: Install packages arm gcc
        run: |
          sudo apt update
          sudo apt install -y -o Acquire::Retries=50 \
                           mtools syslinux isolinux genisoimage xorriso mtools \
                           gcc-arm-none-eabi \
                           gcc-aarch64-linux-gnu \
                           g++-9-aarch64-linux-gnu
      - name: Build ARM32
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          make -j $((`nproc`+0)) -C src CROSS=arm-none-eabi- \
               bin-arm32-efi/intel.efi \
               bin-arm32-efi/intel.usb \
               bin-arm32-efi/intel.iso
      - name: Build ARM64
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          make -j $((`nproc`+0)) -C src CROSS=aarch64-linux-gnu- \
               bin-arm64-efi/ipxe.efi \
               bin-arm64-efi/ipxe.usb \
               bin-arm64-efi/ipxe.iso

      - name: Install for ISO build
        run: |
          sudo apt install -y -o Acquire::Retries=50 \
                           mtools syslinux isolinux \
                           p7zip-full genisoimage mtools isolinux syslinux syslinux-efi syslinux-utils xorriso
      - name: Build ISO
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          find . \( -name "*.lkrn" -or -name "*.efi" -or -name "*.iso" \) \( ! -name "Makefile*" \) -print
          cd src && ./util/genfsimg -o ipxe-all-arch.iso -s menu.ipxe \
          bin-i386-efi/ipxe.efi \
          bin-x86_64-efi/ipxe.efi \
          bin-arm32-efi/ipxe.efi \
          bin-arm64-efi/ipxe.efi \
          bin/ipxe.lkrn || \
          ./util/genfsimg -o ipxe-any.iso bin-*-efi/ipxe.efi bin/ipxe.lkrn
      - name: list ISO
        run: |
          find . \( -name "*.lkrn" -or -name "*.efi" -or -name "*.iso" \) \( ! -name "Makefile*" \) -print
          isoinfo -d -i src/*.iso
          isoinfo -l -i src/*.iso
          find . \( -name "*.lkrn" -or -name "*.lkr" -or -name "*.efi" -or -name "*.iso" \) \( ! -name "Makefile*" \) -exec 7z l '{}' ';'
      - name: Build (Everything)
        if: ${{ env.build-Everything == 'true' }}
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          make -j$((`nproc`+0)) -C src everything
      - name: Build ISO (Everything)
        if: ${{ env.build-Everything == 'true' }}
        run: |
          export PATH="/usr/local/lib/ccache:/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          find . \( -name ipxe.lkrn -or -name ipxe.efi \) -print
          cd src && ./util/genfsimg -o ipxe-all-arch.iso -s menu.ipxe \
          bin-i386-efi/ipxe.efi \
          bin-x86_64-efi/ipxe.efi \
          bin-arm32-efi/ipxe.efi \
          bin-arm64-efi/ipxe.efi \
          bin/ipxe.lkrn || \
          ./util/genfsimg -o ipxe-glob.iso bin-*-efi/ipxe.efi bin/ipxe.lkrn
      - name: list ISO (Everything)
        if: ${{ env.build-Everything == 'true' }}
        continue-on-error: true
        run: |
          set -vx
          find . \( -name "*.lkrn" -or -name "*.lkr" -or -name "*.efi" -or -name "*.iso" \) \( ! -name "Makefile*" \) -print
          isoinfo -d -i src/*.iso
          isoinfo -l -i src/*.iso
          find . \( -name "*.lkrn" -or -name "*.lkr" -or -name "*.efi" -or -name "*.iso" \) \( ! -name "Makefile*" \) -exec 7z l '{}' ';'
      - name: Test
        if: ${{ env.build-Everything == 'true' }}
        #continue-on-error: true
        run: |
          valgrind ./src/bin-i386-linux/tests.linux
          valgrind ./src/bin-x86_64-linux/tests.linux
###
      - name: ssh
        if: ${{ false && env.ryanchapman-gha-ssh == 'true' }}
        continue-on-error: false
        #if: ${{ failure() }}
        #if: ${{ true() }}
        #continue-on-error: true
        uses: ryanchapman/gha-ssh@v1
      # after the container starts tmate in the background, it will
      # sleep for 24 hours, so it's important that you set a timeout here
      # so you doif: ${{ failure() }}n't run up your GitHub Actions bill
        timeout-minutes: 10
        with:
        # authorized_github_users: required
        # List of GitHub users who are allowed to ssh into container.
        # On gha-ssh container start, it downloads the ssh public key(s) for each
        # user from GitHub and places it in ~/authorized_keys
        # tmate is started with `-a ~/authorized_keys` to only allow access
        # to users with possession of the corresponding private ssh keys.
          #authorized_github_users: 'johndoe,janedoe'
          authorized_github_users: 'woa7'
        # debug: optional
        # defaults to `false` if not set here
        # if debug is set, then tmate is started with `-vvv -F`
          debug: true
      - name: foo run
        run: |
          echo foo
###

